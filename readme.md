# Заметки по THREE.js

## Содержание
* [Вступление](#вступление)
  * [Проект WEBVKUBE. Первый бесплатный курс на youtube](#проект-webvkube-первый-бесплатный-курс-на-youtube)
    * [Урок 1. Введение](#урок-1-введение)
    * [Урок 2. Модули, импорт, экспорт](#урок-2-модули-импорт-экспорт)
      * [Экспорт и импорт](#экспорт-и-импорт)
      * [Подключение модулей и вызов на странице](#подключение-модулей-и-вызов-на-странице)
    * [Урок 3. Создаем простую сцену](#урок-3-создаем-простую-сцену)
    * [Урок 4. Объект3D, его параметры и методы](#урок-4-объект3d-его-параметры-и-методы)
    * [Урок 5. Перемещение и векторы](#урок-5-перемещение-и-векторы)
    * [Урок 6. Поворот объектов](#урок-6-поворот-объектов)
    * [Урок 7. Геометрия объектов](#урок-7-геометрия-объектов)
* [Документация](#документация)
  * [Объекты](#объекты)
  * [Меш](#меш)
  * [Геометрия](#геометрия)
  * [Материал](#материал)
  * [Сцена](#сцена)
  * [Туман](#туман)
  * [Камера](#камера)
  * [Свет](#свет)
  * [Вектор](#вектор)
  * [Эйлер](#эйлер)
  * [Кватернион](#кватернион)
  * [Лоадер](#лоадер)
  * [Рендер](#рендер)
  * [Дополнительные модули](#дополнительные-модули)

## Вступление
[Вернуться к содержанию][toc]

Изначально в данном документе были заметки по бесплатному курсу по THREE.js от [webvkube]. Но позже я решил добавить информацию и по другим материалам. Еще есть заметки/перевод документации. Перевод вольный, сверяйте все с официальной документацией.

К бесплатному курсу был ограничен доступ. Ссылки оставлю на всякий случай. Если что - все вопросы в группу автора. Материал очень крутой! :thumbsup:

##### VS Code Intellisense для THREE.js

Я использую VS Code и Intellisense для библиотеки THREE.js заработал автоматически после импорта библиотеки. Но на всякий случай могу предложить почитать [здесь][vscode_intellisense] как сделать себе в редакторе Intellisense для THREE.js, если вдруг автоматически не заработал.

### Проект WEBVKUBE. Первый бесплатный курс на youtube
[Вернуться к содержанию][toc]

* [Канал][youtube_main_channel] уроков на Youtube.
* [Группа ВК][vk_kurspothreejs]

Список уроков начального бесплатного курса на Youtube :
* Урок 01. [Введение.](https://www.youtube.com/watch?v=DRiVzLca3xc)
* Урок 02. [Модули, импорт, экспорт.](https://www.youtube.com/watch?v=scAiW8rzvLc)
* Урок 03. [Создаем простую сцену.](https://www.youtube.com/watch?v=ECAYu1mZUzM)
* Урок 04. [Объект3D, его параметры и методы.](https://www.youtube.com/watch?v=dADyZorNysU)
* Урок 05. [Перемещение и векторы.](https://www.youtube.com/watch?v=MJUOLZyI7iE)
* Урок 06. [Поворот объектов.](https://www.youtube.com/watch?v=NYqh5flYKEo)
* Урок 07. [Геометрия объекта.](https://www.youtube.com/watch?v=lm7uXWyziFs)
* Урок 08. [Материалы.](https://www.youtube.com/watch?v=aOkmujuzO2M)
* Урок 09. [Текстуры, свет, камеры.](https://www.youtube.com/watch?v=0FW3kyuRyyw)
* Урок 10. [Ресайз, Взаимодействие с объектом.](https://www.youtube.com/watch?v=yHQugrtmkH4)
* Урок 11. [Создаем платформер часть 1.](https://www.youtube.com/watch?v=gXwsuVicjV4)
* Урок 12. [Состояния. Создаем платформер часть 2.](https://www.youtube.com/watch?v=ap2Y3G6RE0c)
* Урок 13. [Создаем платформер часть 3. ИИ Проверка нанесения урона.](https://www.youtube.com/watch?v=y5ZlQeQOtAg)

#### Урок 1. Введение
[Вернуться к содержанию][toc]

Официальный сайт проекта [THREE.js][three_js_site].

Скачать библиотеку three.js с [GitHub][three_js_github_build].

#### Урок 2. Модули, импорт, экспорт
[Вернуться к содержанию][toc]

Лучше организовать код и работу с ним через модули.

##### Экспорт и импорт
[Вернуться к содержанию][toc]

* Если **в файле только один класс, объект или переменная**, то экспорт можно делать через слово `default`, а при импорте просто указываем переменную, куда складываем импортированные данные.

```javascript
// ./js/data.js

export default 1; // например, экспортируем просто число

// или
export default class{}; // может быть класс

// или
export default {}; // может быть объект
```

```javascript
// ./js/app.js

import a from './js/data.js';
alert(a);
export default true;
```

* Если **в файле несколько переменных, объектов или классов**, то надо их сначала объявить, потом через { } экспортировать. При импорте тоже нужно указать фигурные скобки { }.

```javascript
// ./js/data.js

let a = 1;
export {a};
```

```javascript
// ./js/app.js

import {a} from './js/data.js';
alert(a);
export default true;
```

* Если **экспортируем несколько переменных**, указываем их через запятую , . Импортируем также через через запятую , .

```javascript
// ./js/data.js

let a = 1;
let b = 3:
export {a, b};
```

```javascript
// ./js/app.js

import {a, b} from './js/data.js';
alert(a);
alert(b);
export default true;
```

* Если нужно **экспортировать все**, то указываем через `* as` и указываем имя родителя.

```javascript
// ./js/app.js

import * as data from './js/data.js';
alert(data.a);
alert(data.b);
export default true;
```

* Иногда модули нужны только **для объединения других модулей** модулей. Тогда вместо `import` пишем `export`, а импорт также делам через `* as`.

```javascript
// ./js/data.js

let a = 1;
let b = 3:
export {a, b};
```

```javascript
// ./js/app.js

export * from './js/data.js'; // в данном случае файл является передаточным звеном
```

```html
<!-- ./index.html -->

<script type="module">
  import * as app from './js/app.js';
  console.log(app.a, app.b);
</script>
```

* Также, **для объединении нескольких файлов** нужно просто их добавить.

```javascript
// ./js/app.js

export * from './js/data.js';
export * from './js/data1.js';
export * from './js/data2.js';
export * from './js/data3.js';
// и т.д.
```

##### Подключение модулей и вызов на странице
[Вернуться к содержанию][toc]

* **Подключение приложения** в текущем подходе осуществляется в index.html:

```html
<!-- ./index.html -->

<script type="module">
  import app from './js/app.js';
</script>
```

В данном случае, `app` может быть любым другим словом.

#### Урок 3. Создаем простую сцену
[Вернуться к содержанию][toc]

Все 3d базируется на нескольких понятиях, о которых нужно помнить при создании приложения. Это:
1. Объект:
    * Геометрия;
    * Материал.
2. Сцена.
3. Камера.
4. Свет.
5. Рендер.

Модуль приложения описан в файле app.js. Пока что там экспортируются только 2 дефолтные функции: **init** для инициализации проекта и **update** для постоянной прорисовки (рендера) картинки. В index.html этот модуль подключается и там же вызывается инициализация приложения. Обрати внимание на то, что <span id="lesson-3-renderer-recursion-update-function">рекурсивная функция рендерера update</span> построена так: в ней сначала запоминается контекст выполнения функции, который нам нужен, а только потом будет рекурсия нашего контекста. Это в данном примере так. Дальше посмотрим, может что поменяется. Дополнительно в index.html для body задаются отступы 0 и overflow: hidden, т.к. почему-то вылезает скролбар все время. Возможно, у других это не так.

```html
<!-- index.html -->

<style>
  body {
    margin: 0;
    overflow: hidden;
  }
</style>

<script type="module">
  import app from './js/app.js';
  app.init();
</script>
```

```javascript
// app.js

export default {

  // функция инициализации приложения
  init: function () {
    // тут объявляются все объекты, сцены, камеры, свет и т.д.
    this.update();
  },

  // функция прорисовки (обновления картинки)
  update: function () {
    let that = this; // здесь сохранили контекст выполнения
    this.renderer.render(this.scene, this.camera); // запустили рендерер
    requestAnimationFrame( function () {
      that.update();
    }); // рекурсивно вызвали функцию обновления
  }
};
```

#### Урок 4. Объект3D, его параметры и методы
[Вернуться к содержанию][toc]

Объекты можно добавлять друг в друга. Тогда создается иерархия объектов: родитель -> потомок. И если, например, двигать родителя, то потомок тоже будет двигаться.

Задавать цвет стандартного материала (наверное, и не только) можно через метод `.setHex()`, например, `obj.material.color.setHex(0xff00bb)`.

Отличие функции `.clone()` от `.copy()` в том, что когда мы копируем, то 2й объект уже создан.

#### Урок 5. Перемещение и векторы
[Вернуться к содержанию][toc]

Векторы отвечают за направление. Обычно направление задано нормальизованным вектором (т.е. его длина равна 1). Для перемещения нормализованный вектор умножают на скорость.

**Чтобы направить** объект2 **следовать за другим** объектом1, нужно:
1. Находить постоянно вектор-разницу между о1 и о2 - `.subVectors()`.
2. Задавать постоянно длину найденного вектора (или нормализовать и умножить на скорость).
3. Добавлять постоянно все время к позиции о2 полученный вектор.

`.position.distanceTo()` **лучше не применять**, если в сцене много объектов. Это ресурсозатаратно, т.к. в каждой операции считается извлечение корня. Дистанция до объекта находится как корень квадратный из суммы квадратов проекций по осям x и y от объекта до объекта. Т.е. по теореме Пифагора. Более **быстрая версия этой функции** - функция `.position.distanceToSquared()`. Она не извлекает корень при расчете дистанции.

Т.к. многие методы у векторов возвращают тоже вектор, то можно писать сложные последовательные констркуции через точку, типа `vec1.add(vec2.position).multiplyScalar(2).normilize();` и т.д.

**Чтобы вращать** объект2 **вокруг другого** объекта1, нужно:
1. Раз определить угол = 0.
2. Постоянно изменять угол на какую-то величину.
3. Задавать постоянно позицию объекта2 по x = 0 + N * Math.cos(угол).
4. Задавать постоянно позицию объекта2 по y = 0 + N * Math.sin(угол).
Здесь N - это расстояние от объекта1 до объекта2.

**Один из вариантов выполнения ДЗ.** Мое первое решение. Делаем сферы и куб. Куб ставим на сферу. В апдейте пишем: Если дистанция от сферы до куба меньше 0.01, то вектор направления = вектор сферы 2 - вектор сферы 1. И так для каждоый сферы. А после условия устанавливаем длину вектора и добавляем его к позиции куба.

#### Урок 6. Поворот объектов
[Вернуться к содержанию][toc]

А вот и **решение предыдущей задачи** из Урока 5. Я был близок к пониманию :smile:

1. Делаем массив сфер.
2. Заполняем его сферами.
3. В цикле задаем каждой сфере произвольное положение, добавляем сферу в сцену, добавляем сферу в массив.
4. Присваиваем переменной 1й объект массива.
5. Делам счетчик, в котором храним номер сферы.
6. В апдейте находим направление как разницу векторов текущего элемента массива сфер и куба. Задаем ему тут же длину. Прибавляем вектор к положению куба.
7. Потом проверка: если дистанция от куба до текущего элемента массива сфер меньше половины направления, то счетчик увеличивается на 1. И если счетчик дошел больше длины массива со сферами, то счетчик сбрасывается на 0.

Единственное помни, что проверять достижение нужной координаты через ориентирование на дистанцию в половину меньше направления, не совсем верно. Это верно только когда путь, который нужно пройти, больше длины вектора направления (включая скорость). Так что всегда проверять надо этот момент.

ДЗ сложно пока.

#### Урок 7. Геометрия объектов
[Вернуться к содержанию][toc]

Геометиря - каркас объекта. Есть буферная геометрия - это когда все треугольники сами по себе. Есть обычная геометрия - это когда вершины треугольников соединены. Буферная геометрия исползьуется когда в сцене очень много объектов - она считается быстрее. Обычная геометрия - когда надо деформировать объект.

При загрузке моделей загрузчики обычно переводят модели в буферную геометрию. Если нужно работать с обычной геометрией, бери метод `.fromBufferGeometry()`.

Для загрузки текутур используй текстурный лоадер `new THREE.TextureLoader().load(путь к текстуре);`.

При создании геометрии нужно создать новую геометрию, потом к ней добавить вершин и добавить фейс. Все это массивы. Вершины добавляются как новые Vector3, фейсы - как новые Face3. Параметром в Face3 передается номера точек по порядку из массива vertices. Если перечисление точек идет против часовой стрелки по отношению к смотрящему, то созданный фейс будет виден - это его лицевая сторона. Если по часовой - то будем видеть заднюю сторону фейса. Обычно, она не видна. Тогда в материале нужно включать параметр `side: THREE.DoubleSide` (даблсайд - это константа).

При добавлении UV развертки сначала делают пустой массив `.faceVertexUvs`, и этот массив содержит слои. Слои - это разные развертки. Т.е. у объекта могут быть разные развертки материалов, больше, чем одна. Только потом в эти слои добавляют фейсы, а в фейсы координаты точек развертки, только уже в 2d пространстве через Vector2. Потом надо обносить положение UV координат через включить `.uvsNeedUpdate;`. Это надо на массивах с большим количеством элементов, т.к. автоматически они могут не обновиться. осле нужно пересчитать границы через `.computeBoundingSphere();`. После нужно пересчитать нормали через `.computeVertexNormals();`.

Если нужно постоянно двигать точки, то в функции апдейт нужно постоянно включать `.verticesNeedUpdate`, т.к. этот флаг постоянно сбрасыавет в false.

**ДЗ**

Итак, уже лучше! Получилось сделать анимацию, но не получилось прикрутить ее на клик по документу. Почему-то.

Мое решение: делаем переменные верхней границы, нижней границы. Это будут границы перемещения вершин.Также, определяем переменную дистанции, с которой будем постоянно сравнивать координаты точек. И определяем скорость с которой будут происходить изменения и знак направления движения. Потом определяем центральную точку объекта через (количество точек / 2) и округляем вниз полученное значение. Т.к. треугольники в пресетах создаются один за другим, то как раз в центр и попадаем. Дальше в апдейте пишем следующее: через цикл for от 0 до количества точек в плоскости делаем проверку: если дистанция от i-ой точки до центральной точки меньше или равно дистанции, то м начинаем двигать точку по z (тут вложенный цикл), и если дистанция от i-ой точки до центральной точки меньшу дистанции и еще и минус определенное число, то координата по z = 0. Зачем так? Волна прошла и точки должны вернуться в исходное положение.

Что касается вложеного цикла: там проверка если значение координаты z > верхнего порога, то знак (направление движения) меняется на противоположный, если меньше нижнего порога, то меняется на положительный.

Я был близок. Реализация в уроке 8, конечно, другая. Но совпало, что определял расстояние, проходил по все через for и ставил условия по сравнению с дистанцией. Короче, примерно попал.

## Документация
[Вернуться к содержанию][toc]

Здесь коротко собираю информацию, чтобы не забыть про объекты, параметры функций, варианты и т.д.

[Офиициальная документация][three_js_doc_site] по THREE.js

### Объекты
[Вернуться к содержанию][toc]

Вообще-то, объектом может быть все в приложении: меш, камера, источник света, сцена. В свою очередь меш это объект, который состоит из геометрии и материала.

Все объекты наследуются от класса `Object3D`.

* **Object3D**

Можем создать пустой объект (болванку), для помещения в нее других объектов

```javascript
let someObj = new THREE.Object3D();
```

**Cвойства**

```javascript
// Вложенные объекты / массив с потомками (Array)
.children;

// свойство, хранящее всю геометрию
.geometry

// Номер объекта (Integer, def: empty)
.id;

// Имя объекта (String)
.name;

// Родитель / ссылка на объект по иерархии выше
.parent;

// Позиция и варианты как ее задать (positiob - это Vector3, запомни!)
.position.x; // а также .y и .z
.position.set(x, y, z); // задается сразу 3 координаты
.position.add(Vector3);

// Поворот (Quaternion). См. раздел по кватернионам дополнительно
.quaternion;

// Поворот (Euler)
.rotation.x; // а также .y и .z (в радианах)
.rotation.reorder('YXZ'); // большими буквами, например для переопределения последовательности поворотов. Это нужно делать до поворота объекта

// Масштаб (Vector3)
.scale.x; // а также .y и .z

// Видимость объекта в сцене (Boolean, def: true)
.visible;
```

**Методы**

```javascript
// Добавить объект в объект
.add(Object);

// Отбрасывать тени (Boolean, def: false)
.castShadow();

// Клонировать объект (геометрия и материал остаются прежними)
// Также, можно клонировать материал, например
.clone()
// ex
cube1 = cube2.clone();

// Копирование объектов. Копирует информацию с другоого объекта
.copy(Object);

// Поиск объекта по id
.getObjectById(Integer)

// Поиск объекта по имени
.getObjectByName(String)

// Поворот объекта на определенную точку или другой объект
.lookAt(x, y, z);
// ex
camera.lookAt(cube.position);
camera.lookAt(1, 5, 3);

// Удалить объект из объекта
.remove(Object);

// Перемещение относительно локальных координат объекта
.translateX(Float);
.translateY(Float);
.translateZ(Float);
```

* **AxesHelper**

Включает оси сцены для подмоги.

```javascript
const axesHelper = new THREE.AxesHelper( 5 );
scene.add(axesHelper);
```

* **Группы**

Создает группу объектов, в которую добавляем еще объекты.

```javascript
const group = new THREE.Group();
group.add(cubeA);
scene.add(group);
```

### Меш
[Вернуться к содержанию][toc]

Наследуется от `Object3D`.

* **Меш**

Меш включает в себя геометрию и материал. Это то, что мы увидим как объект в сцене. Например, стул, дерево, мяч и т.д. - все это будут мэши со свое геометрией и материалами.

```javascript
let mesh = new THREE.Mesh(геометрия, материал);
```

### Геометрия
[Вернуться к содержанию][toc]

Можно создавать геометрию пресетами, например, `.BoxGeometry, .SphereGeometry` и т.д. А можно создавать свою геометрию. Например, см. ниже

```javascript
let geometry = new THREE.Geometry();

geometry.vertices.push(
  new THREE.Vector3(-1, 1, 0),
  new THREE.Vector3(-1, -1, 0),
  new THREE.Vector3(1, -1, 0),
);

geometry.faces.push(
  new THREE.Face3(0, 1, 2)
);

geometry.computeBoundingSphere();
geometry.computeVertexNormals();
```

Помни, что геометрии нужны точки и фейсы. Фейсы - это плоскость/треугольник, соединяющий 3 точки.

У объектов есть свойство `.geometry`.

Все точки обычной геометрии хранятся в свойстве `.vertices`. Все точки буфферной геометрии хранятся в `.attributes.position.array`

**Свойства**

```javascript
// массив фейсов треугольников. В массиве по порядку идут массив с данными фейса.
// В этом массиве параметры a, b, c обозначают порядковый номер вершины из .vertices
.faces

// Развертка фейса. Здесь хранятся координаты точек в UV пространстве (двухмерное).
// Начало координат - левый нижний угол
// Порядковый номер в этом массиве равен порядковому номеру фейса в `.faces`
.faceVertexUvs

// массив хранит координаты всех точек (обычная геомерия)
.vertices

// для обновления положение точек (Boolean)
.verticesNeedUpdate;

// для обновления положения точек UV (Boolean)
.uvsNeedUpdate;
```

**Методы**

```javascript
// клонировать геометрию
.clone();

// копировать геометрию
.copy();

// расчитать сферу с радиусом самой дальней точкой объекта для того,
// чтобы объект не отображался, если эта сфера не попадает в зону видимости камеры
.computeBoudingSphere();

// пересчет нормали. Нужно после создания своей геометрии, чтобы инициализировать нормали
.computeVertexNormals();

```

* **Куб**

Может быть неравносторонним. Размеры в числах. Принимаем, что 1 = 1 м.

```javascript
let boxGeometry = new THREE.BoxGeometry(ширина, высота, глубина, подразделение по x, .. по y, .. по z ); // обычная геометрия, подразделение означает subdivision
let boxGeometry = new THREE.BoxBufferGeometry(ширина, высота, глубина); // буфферная геометрия
```

* **Сфера**

Размеры в числах.

```javascript
let sphereGeometry = new THREE.SphereGeometry(радиус, кол-во ребер по горизонтали, кол-во ребер по вертикали);
```

### Материал
[Вернуться к содержанию][toc]

* **Стандартный материал**

Просто покрывает мэш в заданный цвет. В параметр материала передаются свойства в виде объекта { }. Задаются свойства цвета, шераховатости, прозрачности, металлизированности, карты нормалей, AO и т.д. Формат цвета `0x000000` - последние 6 цифр это RRGGBB в 16-ричной системе счисления от 0 до f.

<!-- TODO добавь описание параметров -->
```javascript
let materialStandart = new THREE.MeshStandartMaterial({
  color: 0x000000,
  wireframe: false, // def: false
  map: переменная, // сюда передаем текстуру
  side: THREE.DoubleSide, // отрисовка материала с двух сторон
  flatShading: true, // включает flat shading (def: false), это противоположность smooth shading
  // ....
});

// Менять свойства можем так:
someObj.material.color.setHex(0x000000);
```

### Сцена
[Вернуться к содержанию][toc]

* **Сцена**

Наследуется от `Object3D`.

Сцена как коробка, в которую складывают все объекты и в которой разворачиваются все действия. Перед запуском отрисовки (рендером), надо поместить все объекты, включая меши, свет, камеры. Без добавления в сцену объектов они просто не будут отрисовываться. Сцене можно задавать туман двух видов: линейный и экспоненциальный.

```javascript
let scene = new THREE.Scene();
```

**Свойства**

**Методы**

```javascript
// добавляем в сцену объекты
scene.add(перечисляем что добавляем);

// Редактировать линейный туман сцены
scene.fog = new THREE.Fog();

// Редактировать экспоненциальный туман
scene.fog = new THREE.FogExp2();

```

### Туман
[Вернуться к содержанию][toc]

Класс с туманом. Есть линейный туман и экспоненциальный туман.

* Линейный туман

```javascript
```

### Камера
[Вернуться к содержанию][toc]

Наследуется от `Object3D`.

* **Перспективная** камера

Наследуется от `Object3D -> Camera`.

Показывает картинку с учетом перспективы. Так можно понять глубину картинки. Объекты при приближении и удалении меняют размер. Есть перспектива. Понятно, да? :wink: В параметры передаем угол обзора (FOV, field of view) бери 60 или 75 для начала; отношение сторон для отображения бери window.innerWidth / window.innerHeight; ближнюю границу клиппинга бери 0.1; дальнюю границу клиппинга бери 100 для начала.

```javascript
let cameraPersp = new THREE.PerspectiveCamera(угол обзора,
  отншение сторон для отображения,
  ближняя граница прорисовки,
  дальняя граница прорисовки);
```

**Методы**
```javascript
// Обновление матрицы - нужно постоянно при изменнеии какого-либо параметра камеры. Например, после обновления соотношения ширины/высоты (aspect ratio) при обновлении размеров окна
.updateProjectionMatrix();
```

* **Ортографическая** камера

Наследуется от `Object3D -> Camera`.

Это для отображения плоских сцен. 2d, например. Здесь не будет видно перспективы. Объекты на разном расстоянии будут одинакового размера.
<!-- TODO опиши параметры ортографической камеры и какие для начала брать значения -->

```javascript
let cameraOrto = new THREE.OrtographicCamera();

// пример
let cameraOrto = new THREE.OrtographicCamera(innerWidth / -100, innerWidth / 100, innerHeight / 100, innerHeight / -100, 0.1, 100);
```

### Свет
[Вернуться к содержанию][toc]

Наследуется от `Object3D`.

* **Гемисферический** источник света.

Наследуется от `Object3D -> Light`.

Свет будет подаваться сверху и снизу. Цвета верхнего и нижнего света в формате `0x000000`; интенсивность в числах бери 1 для начала.

```javascript
let lightHemi = new THREE.HemisphereLight(цвет верхнего света, цвет нижнего света, интенсивность источника света)
```

### Вектор
[Вернуться к содержанию][toc]

Это про направления.

* **Vector3**

Это трехмерный вектор с координатами x, y, z. При создании можем сразу указать координаты x, y, z (def: 0, 0, 0). Но это не обязательно.

```javascript
let direction = new THREE.Vector3d();
```

**Свойства**

Координаты x, y, z.

```javascript
.x // или .y или .z
```

**Методы**

```javascript
// Добавить вектор
.add(Vector3);

// Добавить число к координате
.addScalar();

// Сложить два вектора.
.addVectors(вектор1, вектор2)

// Тут подробней посмотри - это про поворот вектора
// (из задачи про 'хотьбу' кубика из урока 6 с разбором в уроке 7)
.applyAxisAngle(вектор, угол поворота);

// Клонировать - создает новый вектор на основе другого
.clone();

// Копирует данные - копирует в уже сущетвующий вектор данные другого
.copy(Vector3);

// Деление вектора
.divide(Vector3);

// Деление вектора на число
.divideScalar();

// Узнать дистанцию до объекта (посмтри пример в уроке 5 - в блоке if сравнение)
.distanceTo(Vector3);

// Узнать дистанцию до объекта (в квадрате) - нужна для более быстрой работы,
// чем distancTo(), т.к. не вычисляет квадратный корень,
// т.е. нужна только для сравнения / поиска расстояния между объектами
.distanceToSquared();

// Узнать длину вектора
.length();

// Узнать длину вектора в квадрате
.lengthSq();

// Умножение вектора на вектор
.multiply(Vector3);

// Умножение вектора на число
.multiplyScalar(Float);

// Умножение векторов
.multiplyVectors(Vector3, Vector3);

// Нормирование вектора
.normilize();

// Задать позицию вектора, в числах
.set(x, y, z);

// Задать длину вектора
.setLength(Float);

// Вычитание вектора из вектора
.sub(Vector3);

// Вычитание числа из координат вектора
.subScalar(Float);

// Вычитание двух векторов в переменную (вектор). Оба параметра: Vector3.
.subVectors(уменьшаемое, вычитаемое);
```

### Эйлер
[Вернуться к содержанию][toc]

Нужен для поворотов - это просто поворот вокруг оси x, y или z.
При создании указываем на сколько повернуть по каждой из осей и 4й параметр - порядок осей при повороте (очень важно это. Пишется большими буквами).

```javascript
let eul = new THREE.Euler(x, y, z, 'XYZ');
```

**Свойства**

```javascript
// Задает порядок осей для поворота ('XYZ')
.order;
```

**Методы**

```javascript
// Клонирование эйлера
.clone();

// Копирование эйлера
.copy(другой эйлер);

// Переопределение поряка поворота по осям (как .order, только .reorder лол:)).
// Тут смысл в том, что может быть большая цепочка действий черзе точку. Вот тут этот метод и пригодится.
.reorder(новый порядок)

// Задать эйлер
.set(x, y, z, порядок);
```

### Кватернион
[Вернуться к содержанию][toc]

Это лютая дичь, которая нужна для поворота объектов вокруг заданной оси и заданноу углу.

**Свойства**


**Методы**

```javascript
// Поворот вокруг указанной оси (Vector3) на определенный угол в радианах (Float)
.setFromAxisAngle(ось, угол поворота вокруг оси)
```
### Лоадер
[Вернуться к содержанию][toc]

* **Текстурный лоадер**

Наследуется от `Loader`.

```javascript
let texture = new THREE.TextureLoader()
```

**Методы**

```javascript
// Загрузить текстуру
.load(путь к тектсуре, тут еще есть параметры, см. документацию);
```

### Рендер
[Вернуться к содержанию][toc]

Рендер. Рендерер. Прорисовыватель всего того, что ты построил. Делает картинку. Для статичной картинки его можно вызвать один раз. Для работы приложения его нужно вызывать каждый кадр, т.е. чтобы каждый кадр перерисовывалась сцена. Обычно это 60 кадров в секунду (60 fps). Тогда рендерер помещают либо в таймер, либо в рекурсивную функцию.

* **WebGLRenderer**

Рендер на технологии WebGL. В примере ниже рендереру задают размеры как DOM-элементу и добавляют на страницу в body. По поводу рекурсии посмотри еще как это в уроке 2 было [сделано](#lesson-3-renderer-recursion-update-function).

```javascript
let renderer = new THREE.WebGLRenderer();

// задаем размер рендерера (канваса)
renderer.setSize(window.innerWidth, window.innerHeight);
// и добавляем его на страницу
document.body.appendChild(renderer.domElement);
```

```javascript
// вариант реализации рекурсивной функции рендера приложения

function update() {
  // здесь описывается что должно происходить каждый кадр:
  // анимация, перемещение объектов и т.д.
  renderer.render(сцена, камера)
  requestAnimationFrame( function () {
    update();
  });
};
```

**Методы**

```javascript
// Задать соотношение пикселей 1 (обычно) или 2. Нужно для экранов ретины, чтобы не было размытых краев на объектах. Т.к. больше 2 уже не нужно из-за того, что это слишком много пикселей будет на квадрат, то выбираем наименьшее из того, что есть - либо 1 будет у девайса по умолчанию, либо будет 2 и тогда выбран будет 2 (для ретины, например), но если будет больше 2, то выберется все равно 2.
.setPixelRatio(Math.min(window.devicePixelRatio, 2))
```

### Дополнительные модули
[Вернуться к содержанию][toc]

Информация из примеров, про дополнительные модули, еще что-то.

* **OrbitControls**

Встроенный контроллер для управления камерой. Подключается отдельно. Находится по пути: `examples/jsm/controls/OrbitControls.js`.
Его можно импортировать: `import { OrbitControls } from 'examples/jsm/controls/OrbitControls.js'`.

```javascript
import { OrbitControls } from 'examples/jsm/controls/OrbitControls.js';

const controls = new OrbitControls(camera, canvas); // достаточно просто добавить переменную
```

**Свойства**

```javascript
.enabled = false; // default is true. Позволяет включать/выключать OrbitControls

// Включает энерцию при управлении камерой
.enableDamping = true; // default is false. При этом обязательно нужно в функцию рендера засунуть обновление контроллера controls.update();

// Задает точку куда будет смотреть камера (Vector3)
.target.x = 2; // (или y, z) и потом надо обязательно обновить контроллер controls.update();

```

**Методы**

```javascript
// обновляет контроллер - нужно делать после любого изменения камеры вручную в коде
.update();
```



<!-- Ссылки -->
[toc]: #содержание
[webvkube]: http://webvkube.ru
[youtube_main_channel]: https://www.youtube.com/channel/UCBnK0ae8Wvu_TEkWmOIwWBw
[vk_kurspothreejs]: https://vk.com/kurspothreejs
[vscode_intellisense]: http://shrekshao.github.io/2016/06/20/vscode-01/
[three_js_site]: http://threejs.org
[three_js_github_build]: https://github.com/mrdoob/three.js/tree/dev/build
[three_js_doc_site]: https://threejs.org/docs/index.html#manual/en/introduction/Creating-a-scene